import os
import json
import argparse
import typing
import json
import numpy as np

from collections import defaultdict
from helper import LABELS


def parse_arguments():
    parser = argparse.ArgumentParser()
    parser.add_argument("--json", help="Path to JSON file with annotated data.")
    parser.add_argument("--alignments", help="Path to folder with the alignments.")
    parser.add_argument("--save", help="Save per-file errors to JSON.", action="store_true")
    parser.add_argument("--info", help="Save example file with alignment and errors", action="store_true")
    parser.add_argument("--ocr", help="Path to folder with ocr.")

    args = parser.parse_args()

    return args


def load_annotations(path: str) -> dict:
    with open(path, "r") as f:
        return json.load(f)


def load_ocr(path: str) -> str:
    with open(path, "r") as f:
        return f.read().replace("\n", " ")


# data[label] = [[text, from, to], ...]
def load_alignment(folder: str, filename: str) -> str:
    path = os.path.join(folder, filename)
    data = {}

    with open(path, "r") as f:
        sep = chr(255)

        for line in f:
            s = line.split(sep)
            label = s[1]

            if label not in data:
                data[label] = [[s[3], int(s[5]), int(s[7])]]

            elif abs(int(data[label][-1][2]) + 1 - int(s[5])) <= 2: # if the label continues on next line
                data[label][-1][0] += s[3]                          # append it to the previous record
                data[label][-1][2] = int(s[7])                      # and update 'to' field

            else:
                data[label].append([s[3], int(s[5]), int(s[7])])

    return data


def generate_file_index(annotations) -> int:
    index = np.random.randint(low=0, high=len(annotations) - 1)

    while "label" not in annotations[index]:
        index = np.random.randint(low=0, high=len(annotations) - 1)

    return index


def print_results(total_error: float, field_error: dict) -> None:
    print(f"Total error = {total_error}\n")
    print(f"Field average errors:")
    print(json.dumps(field_error, indent=4))


def save_results(file_errors: list) -> None:
    with open("alignment_results.json", "w") as f:
        f.write(json.dumps(file_errors, indent=4))


def save_example_file(content: list) -> None:
    with open("example_result.txt", "w") as f:
        for line in content:
            f.write(line)


def main() -> int:
    args = parse_arguments()

    annotations = load_annotations(args.json)

    field_intersections = {label: 0 for label in LABELS}
    field_unions = {label: 0 for label in LABELS}

    total_intersection = 0
    total_union = 0

    file_errors = []

    if args.info:
        file_index = generate_file_index(annotations)
        example_file = []

    for i, annotated_file in enumerate(annotations):
        if "label" in annotated_file: # Filter out wrong matches
            filename = annotated_file["text"].rpartition("/")[2]

            alignment = load_alignment(args.alignments, filename) # Dictionary loaded from file generated by alignment script

            file_total_intersection = 0
            file_total_union = 0
            file_intersections = {}
            file_unions = {}

            if args.info and i == file_index:
                ocr = load_ocr(os.path.join(args.ocr, filename))
                example_file.append(f"File: {filename}\n\n")

            # Go through the annotation
            for annotation in annotated_file["label"]:
                label = annotation["labels"][0]

                if label in alignment:
                    min_error = np.inf
                    min_intersection = 0
                    min_union = 0
                    alig_from = 0
                    alig_to = 0

                    for aligned_string in alignment[label]:
                        intersection = max(min(annotation["end"], aligned_string[2]) - max(annotation["start"], aligned_string[1]), 0)
                        union = max(annotation["end"], aligned_string[2]) - min(annotation["start"], aligned_string[1])
                        
                        error = 1 - intersection / union

                        if error < min_error:
                            min_error = error
                            min_intersection = intersection
                            min_union = union
                            alig_from, alig_to = aligned_string[1], aligned_string[2]

                    total_intersection += min_intersection
                    total_union += min_union

                    field_intersections[label] += min_intersection
                    field_unions[label] += min_union

                    file_total_intersection += min_intersection
                    file_total_union += min_union

                    if label in file_intersections:
                        file_intersections[label] += min_intersection
                        file_unions[label] += min_union
                    else:
                        file_intersections[label] = min_intersection
                        file_unions[label] = min_union

                    if i == file_index:
                        annotation_text = ocr[annotation["start"] : annotation["end"]]
                        alignment_text = ocr[alig_from : alig_to]

                        example_file.append(f"Field: {label}\n")
                        example_file.append(f"Annotation: {annotation['start']}-{annotation['end']} ({annotation_text})\n")
                        example_file.append(f"Alignment: {alig_from}-{alig_to} ({alignment_text})\n")
                        example_file.append(f"Error: {100 * min_error} % ({min_intersection} / {min_union} matched)\n\n")

            file_error = {label: 1 - file_intersections[label] / file_unions[label] for label in file_intersections}
            
            try:
                file_error["total_error"] = 1 - file_total_intersection / file_total_union
            except ZeroDivisionError:
                file_error["total_error"] = 1.0

            file_error["filename"] = filename

            file_errors.append(file_error)

    field_errors = {label: 0.0 for label in LABELS}

    for label in field_errors:
        try:
            field_errors[label] = 1 - field_intersections[label] / field_unions[label]
        except ZeroDivisionError:
            field_errors[label] = -1

    print_results(1 - total_intersection / total_union, field_errors)
    
    if args.save:
        save_results(file_errors)

    if args.info:
        save_example_file(example_file)

    return 0


if __name__ == "__main__":
    exit(main())
