import os
import json
import argparse
import typing

from collections import defaultdict
from helper import LABELS


def parse_arguments():
    parser = argparse.ArgumentParser()
    parser.add_argument("--json", help="Path to JSON file with annotated data.")
    parser.add_argument("--alignments", help="Path to folder with the alignments.")
    parser.add_argument("--transcription", help="Path to folder with transcription files.")

    args = parser.parse_args()

    return args


def load_annotations(path: str) -> dict:
    with open(path, "r") as f:
        return json.load(f)

    
def load_ocr(folder: str, filename: str) -> str:
    path = os.path.join(folder, filename)

    with open(path, "r") as f:
        return f.read().replace('\n', '')


# data[label] = [[text, from, to], ...]
def load_alignment(folder: str, filename: str) -> str:
    path = os.path.join(folder, filename)
    data = {}

    with open(path, "r") as f:
        for line in f:
            s = line.split("'")
            label = s[1]
            
            # TODO: Delete the exception handling after we remove all alignment files without 'from' 'to'
            try:
                if label not in data:
                    data[label] = [[s[3], int(s[5]), int(s[7])]]
                elif abs(int(data[label][-1][2]) + 1 - int(s[5])) <= 2: # if the label continues on next line
                    data[label][-1][0] += s[3]            # append it to the previous record
                    data[label][-1][2] = int(s[7])             # and update 'to' field
                else:
                    data[label].append([s[3], int(s[5]), int(s[7])])
            except (IndexError, ValueError):
                continue

    return data


def main() -> int:
    args = parse_arguments()

    annotations = load_annotations(args.json)

    for annotated_file in annotations:
        if "label" in annotated_file: # Filter out wrong matches
            filename = annotated_file["text"].rpartition("/")[2]

            try: # We do not have all the files yes, skipping those we don't have
                alignment = load_alignment(args.alignments, filename) # Dictionary loaded from file generated by alignment script
                ocr = load_ocr(args.transcription, filename) # String containing ocr transcription without \n
            except FileNotFoundError:
                continue

            occurences = {} # { label: 0 for label in LABELS }
            error = {} # { label: -1 for label in LABELS }

            # test file with multiple annotations
            if annotated_file["id"] == 1571:
                for annotation in annotated_file["label"]:
                    annotated_string = ocr[annotation["start"]:annotation["end"]].lower() # Annotated string
                    label = annotation["labels"][0]

                    occurences[label] = 1 if label not in occurences else occurences[label] + 1

                    if label not in alignment: # Label present in annotation but missing in alignment, error = 100 %
                        error[label] = 1.0
                    else:
                        for aligned_string in alignment[label]:
                            intersection = max(min(annotation["end"], aligned_string[2]) - max(annotation["start"], aligned_string[1]), 0)
                            union = max(annotation["end"], aligned_string[2]) - min(annotation["start"], aligned_string[1])
                            
                            IoU = intersection / union

                            error[label] = 1 - IoU if label not in error else error[label] + 1 - IoU

                error = {label: error[label] / occurences[label] for label in error}
                print(error)

    return 0


if __name__ == "__main__":
    exit(main())
