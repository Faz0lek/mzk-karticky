import os
import json
import argparse
import typing
import json

from collections import defaultdict
from helper import LABELS


def parse_arguments():
    parser = argparse.ArgumentParser()
    parser.add_argument("--json", help="Path to JSON file with annotated data.")
    parser.add_argument("--alignments", help="Path to folder with the alignments.")
    parser.add_argument("--save", help="Save results to file.", action="store_true")

    args = parser.parse_args()

    return args


def load_annotations(path: str) -> dict:
    with open(path, "r") as f:
        return json.load(f)


# data[label] = [[text, from, to], ...]
def load_alignment(folder: str, filename: str) -> str:
    path = os.path.join(folder, filename)
    data = {}

    with open(path, "r") as f:
        sep = chr(255)

        for line in f:
            s = line.split(sep)
            label = s[1]

            if label not in data:
                data[label] = [[s[3], int(s[5]), int(s[7])]]

            elif abs(int(data[label][-1][2]) + 1 - int(s[5])) <= 2: # if the label continues on next line
                data[label][-1][0] += s[3]                          # append it to the previous record
                data[label][-1][2] = int(s[7])                      # and update 'to' field

            else:
                data[label].append([s[3], int(s[5]), int(s[7])])

    return data


def print_results(total_error: float, field_error: dict) -> None:
    print(f"Total error = {total_error}\n")
    print(f"Field average errors:")
    print(json.dumps(field_error, indent=4))


def save_results(file_errors: list) -> None:
    with open("alignment_results.json", "w") as f:
        f.write(json.dumps(file_errors, indent=4))


def main() -> int:
    args = parse_arguments()

    annotations = load_annotations(args.json)

    avg_file_errors = []
    avg_field_error = {label: 0.0 for label in LABELS}
    total_occurences = {label: 0 for label in LABELS}
    avg_total_error = 0.0

    for annotated_file in annotations:
        if "label" in annotated_file: # Filter out wrong matches
            filename = annotated_file["text"].rpartition("/")[2]

            alignment = load_alignment(args.alignments, filename) # Dictionary loaded from file generated by alignment script

            occurences = {}
            file_error = {}

            # Case when label present in alignment, but missing in annotation
            annotation_labels = [annotation["labels"][0] for annotation in annotated_file["label"]]
            for label in alignment:
                if label not in annotation_labels:
                    file_error[label] = len(alignment[label])
                    avg_total_error += len(alignment[label])
                    occurences[label] = len(alignment[label]) if label not in occurences else occurences[label] + len(alignment[label])
                    total_occurences[label] += len(alignment[label])

            # Go through the annotation
            for annotation in annotated_file["label"]:
                label = annotation["labels"][0]

                if label not in alignment: # Label present in annotation but missing in alignment, error = 100 %
                    file_error[label] = 1.0
                    avg_total_error += 1.0
                    occurences[label] = 1 if label not in occurences else occurences[label] + 1
                    total_occurences[label] += 1
                else:
                    for aligned_string in alignment[label]:
                        intersection = max(min(annotation["end"], aligned_string[2]) - max(annotation["start"], aligned_string[1]), 0)
                        union = max(annotation["end"], aligned_string[2]) - min(annotation["start"], aligned_string[1])
                        
                        error = 1 - intersection / union

                        file_error[label] = error if label not in file_error else file_error[label] + error
                        avg_total_error += error

                        occurences[label] = 1 if label not in occurences else occurences[label] + 1
                        total_occurences[label] += 1

            # Average file errors over occurences
            file_error = {label: file_error[label] / occurences[label] for label in file_error}

            for label, value in file_error.items():
                avg_field_error[label] += value

            file_error["file"] = filename # Add filename so we can later identify
            avg_file_errors.append(file_error)

    # Average field errors over total occurences
    for label in avg_field_error:
        try:
            avg_field_error[label] /= total_occurences[label]
        except ZeroDivisionError:
            avg_field_error[label] = -1

    avg_total_error /= sum(total_occurences.values())
    
    print_results(avg_total_error, avg_field_error)
    
    if args.save:
        save_results(avg_file_errors)

    return 0


if __name__ == "__main__":
    exit(main())
